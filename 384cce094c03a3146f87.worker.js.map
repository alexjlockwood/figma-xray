{"version":3,"sources":["../webpack/bootstrap","../node_modules/traverse/index.js","analysis/findStyles.tsx","workers/InlineTextStyle.worker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","traverse","obj","Traverse","this","walk","root","cb","immutable","path","parents","alive","walker","node_","node","copy","modifiers","keepGoing","state","concat","parent","length","slice","isRoot","level","circular","update","x","stopHere","delete","remove","isArray","splice","keys","before","f","after","pre","post","stop","block","updateState","objectKeys","isLeaf","notLeaf","notRoot","ret","undefined","push","forEach","child","isLast","isFirst","pop","src","dst","toS","Date","getTime","isRegExp","RegExp","isError","message","isBoolean","Boolean","isNumber","Number","isString","String","getPrototypeOf","constructor","proto","__proto__","T","ps","has","set","map","reduce","init","skip","arguments","acc","paths","nodes","clone","res","toString","Array","xs","fn","args","apply","hasKey","ctx","self","_ref","_ref$data","data","result","file","index","document","type","styles","id","findTextNodesWithInlineStyles","fileData","__webpack_exports__"],"mappings":"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","file":"384cce094c03a3146f87.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/figma-xray/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","var traverse = module.exports = function (obj) {\n  return new Traverse(obj);\n};\n\nfunction Traverse(obj) {\n  this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n  var node = this.value;\n\n  for (var i = 0; i < ps.length; i++) {\n    var key = ps[i];\n\n    if (!node || !hasOwnProperty.call(node, key)) {\n      node = undefined;\n      break;\n    }\n\n    node = node[key];\n  }\n\n  return node;\n};\n\nTraverse.prototype.has = function (ps) {\n  var node = this.value;\n\n  for (var i = 0; i < ps.length; i++) {\n    var key = ps[i];\n\n    if (!node || !hasOwnProperty.call(node, key)) {\n      return false;\n    }\n\n    node = node[key];\n  }\n\n  return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n  var node = this.value;\n\n  for (var i = 0; i < ps.length - 1; i++) {\n    var key = ps[i];\n    if (!hasOwnProperty.call(node, key)) node[key] = {};\n    node = node[key];\n  }\n\n  node[ps[i]] = value;\n  return value;\n};\n\nTraverse.prototype.map = function (cb) {\n  return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n  this.value = walk(this.value, cb, false);\n  return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n  var skip = arguments.length === 1;\n  var acc = skip ? this.value : init;\n  this.forEach(function (x) {\n    if (!this.isRoot || !skip) {\n      acc = cb.call(this, acc, x);\n    }\n  });\n  return acc;\n};\n\nTraverse.prototype.paths = function () {\n  var acc = [];\n  this.forEach(function (x) {\n    acc.push(this.path);\n  });\n  return acc;\n};\n\nTraverse.prototype.nodes = function () {\n  var acc = [];\n  this.forEach(function (x) {\n    acc.push(this.node);\n  });\n  return acc;\n};\n\nTraverse.prototype.clone = function () {\n  var parents = [],\n      nodes = [];\n  return function clone(src) {\n    for (var i = 0; i < parents.length; i++) {\n      if (parents[i] === src) {\n        return nodes[i];\n      }\n    }\n\n    if (typeof src === 'object' && src !== null) {\n      var dst = copy(src);\n      parents.push(src);\n      nodes.push(dst);\n      forEach(objectKeys(src), function (key) {\n        dst[key] = clone(src[key]);\n      });\n      parents.pop();\n      nodes.pop();\n      return dst;\n    } else {\n      return src;\n    }\n  }(this.value);\n};\n\nfunction walk(root, cb, immutable) {\n  var path = [];\n  var parents = [];\n  var alive = true;\n  return function walker(node_) {\n    var node = immutable ? copy(node_) : node_;\n    var modifiers = {};\n    var keepGoing = true;\n    var state = {\n      node: node,\n      node_: node_,\n      path: [].concat(path),\n      parent: parents[parents.length - 1],\n      parents: parents,\n      key: path.slice(-1)[0],\n      isRoot: path.length === 0,\n      level: path.length,\n      circular: null,\n      update: function update(x, stopHere) {\n        if (!state.isRoot) {\n          state.parent.node[state.key] = x;\n        }\n\n        state.node = x;\n        if (stopHere) keepGoing = false;\n      },\n      'delete': function _delete(stopHere) {\n        delete state.parent.node[state.key];\n        if (stopHere) keepGoing = false;\n      },\n      remove: function remove(stopHere) {\n        if (isArray(state.parent.node)) {\n          state.parent.node.splice(state.key, 1);\n        } else {\n          delete state.parent.node[state.key];\n        }\n\n        if (stopHere) keepGoing = false;\n      },\n      keys: null,\n      before: function before(f) {\n        modifiers.before = f;\n      },\n      after: function after(f) {\n        modifiers.after = f;\n      },\n      pre: function pre(f) {\n        modifiers.pre = f;\n      },\n      post: function post(f) {\n        modifiers.post = f;\n      },\n      stop: function stop() {\n        alive = false;\n      },\n      block: function block() {\n        keepGoing = false;\n      }\n    };\n    if (!alive) return state;\n\n    function updateState() {\n      if (typeof state.node === 'object' && state.node !== null) {\n        if (!state.keys || state.node_ !== state.node) {\n          state.keys = objectKeys(state.node);\n        }\n\n        state.isLeaf = state.keys.length == 0;\n\n        for (var i = 0; i < parents.length; i++) {\n          if (parents[i].node_ === node_) {\n            state.circular = parents[i];\n            break;\n          }\n        }\n      } else {\n        state.isLeaf = true;\n        state.keys = null;\n      }\n\n      state.notLeaf = !state.isLeaf;\n      state.notRoot = !state.isRoot;\n    }\n\n    updateState(); // use return values to update if defined\n\n    var ret = cb.call(state, state.node);\n    if (ret !== undefined && state.update) state.update(ret);\n    if (modifiers.before) modifiers.before.call(state, state.node);\n    if (!keepGoing) return state;\n\n    if (typeof state.node == 'object' && state.node !== null && !state.circular) {\n      parents.push(state);\n      updateState();\n      forEach(state.keys, function (key, i) {\n        path.push(key);\n        if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n        var child = walker(state.node[key]);\n\n        if (immutable && hasOwnProperty.call(state.node, key)) {\n          state.node[key] = child.node;\n        }\n\n        child.isLast = i == state.keys.length - 1;\n        child.isFirst = i == 0;\n        if (modifiers.post) modifiers.post.call(state, child);\n        path.pop();\n      });\n      parents.pop();\n    }\n\n    if (modifiers.after) modifiers.after.call(state, state.node);\n    return state;\n  }(root).node;\n}\n\nfunction copy(src) {\n  if (typeof src === 'object' && src !== null) {\n    var dst;\n\n    if (isArray(src)) {\n      dst = [];\n    } else if (isDate(src)) {\n      dst = new Date(src.getTime ? src.getTime() : src);\n    } else if (isRegExp(src)) {\n      dst = new RegExp(src);\n    } else if (isError(src)) {\n      dst = {\n        message: src.message\n      };\n    } else if (isBoolean(src)) {\n      dst = new Boolean(src);\n    } else if (isNumber(src)) {\n      dst = new Number(src);\n    } else if (isString(src)) {\n      dst = new String(src);\n    } else if (Object.create && Object.getPrototypeOf) {\n      dst = Object.create(Object.getPrototypeOf(src));\n    } else if (src.constructor === Object) {\n      dst = {};\n    } else {\n      var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};\n\n      var T = function T() {};\n\n      T.prototype = proto;\n      dst = new T();\n    }\n\n    forEach(objectKeys(src), function (key) {\n      dst[key] = src[key];\n    });\n    return dst;\n  } else return src;\n}\n\nvar objectKeys = Object.keys || function keys(obj) {\n  var res = [];\n\n  for (var key in obj) {\n    res.push(key);\n  }\n\n  return res;\n};\n\nfunction toS(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction isDate(obj) {\n  return toS(obj) === '[object Date]';\n}\n\nfunction isRegExp(obj) {\n  return toS(obj) === '[object RegExp]';\n}\n\nfunction isError(obj) {\n  return toS(obj) === '[object Error]';\n}\n\nfunction isBoolean(obj) {\n  return toS(obj) === '[object Boolean]';\n}\n\nfunction isNumber(obj) {\n  return toS(obj) === '[object Number]';\n}\n\nfunction isString(obj) {\n  return toS(obj) === '[object String]';\n}\n\nvar isArray = Array.isArray || function isArray(xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function forEach(xs, fn) {\n  if (xs.forEach) return xs.forEach(fn);else for (var i = 0; i < xs.length; i++) {\n    fn(xs[i], i, xs);\n  }\n};\n\nforEach(objectKeys(Traverse.prototype), function (key) {\n  traverse[key] = function (obj) {\n    var args = [].slice.call(arguments, 1);\n    var t = new Traverse(obj);\n    return t[key].apply(t, args);\n  };\n});\n\nvar hasOwnProperty = Object.hasOwnProperty || function (obj, key) {\n  return key in obj;\n};","import { FileResponse, Style, TypeStyle, Paint, Effect, Text } from \"figma-js\";\nimport traverse from \"traverse\";\nimport { Index } from \"./indexBuilder\";\nimport { NodePath } from \"./indexBuilder\";\n\ntype FoundTextStyle = {\n  meta: Style;\n  definition: TypeStyle;\n};\ntype FoundFillStyle = {\n  meta: Style;\n  definition: ReadonlyArray<Paint>;\n};\ntype FoundEffectStyle = {\n  meta: Style;\n  definition: ReadonlyArray<Effect>;\n};\n\nexport type FoundStyles = {\n  fill: {\n    [key: string]: FoundFillStyle;\n  };\n  text: {\n    [key: string]: FoundTextStyle;\n  };\n  effect: {\n    [key: string]: FoundEffectStyle;\n  };\n};\n\nfunction hasKey(node: any, key: string) {\n  return node && typeof node === \"object\" && key in node;\n}\n\n/**\n * Finds as many style definitions as it can from within the document.\n *\n * Since style definitions aren't available in the API, we have to find nodes that have styles applied and read the style out of them.\n *\n * This has a limitation that any unused styles can't be read.\n */\n\nexport default function findStyles(file: FileResponse): FoundStyles {\n  const nodesThatHaveStyles = traverse(file.document)\n    .nodes()\n    .filter(node => hasKey(node, \"type\") && hasKey(node, \"styles\"));\n\n  let result: FoundStyles = {\n    fill: {},\n    text: {},\n    effect: {}\n    // also grid and background according to StyleKeyType def.\n  };\n\n  // TODO: this does extra work if the same style has been used multiple times, but I suppose its harmless.\n  nodesThatHaveStyles.forEach(node => {\n    if (node.styles.text) {\n      const id = node.styles.text;\n      result.text[id] = {\n        meta: file.styles[id],\n        definition: node.style\n      };\n    }\n    if (node.styles.fill) {\n      const id = node.styles.fill;\n      result.fill[id] = {\n        meta: file.styles[id],\n        definition: node.fills\n      };\n    }\n    if (node.styles.stroke) {\n      const id = node.styles.stroke;\n      result.fill[id] = {\n        meta: file.styles[id],\n        definition: node.strokes\n      };\n    }\n    if (node.styles.effect) {\n      const id = node.styles.effect;\n      result.effect[id] = {\n        meta: file.styles[id],\n        definition: node.effects\n      };\n    }\n  });\n\n  return result;\n}\n\nexport type NodeWithXRayData = {\n  node: Text;\n  path: NodePath;\n};\n\nexport type InlineTextStyleNodes = Array<NodeWithXRayData>;\n\nexport function findTextNodesWithInlineStyles(\n  file: FileResponse,\n  index: Index\n): InlineTextStyleNodes {\n  return traverse(file.document).reduce(function(\n    acc: InlineTextStyleNodes,\n    node\n  ) {\n    if (node) {\n      if (node.type === \"INSTANCE\") {\n        this.block();\n      } else if (\n        node.type === \"TEXT\" &&\n        (!hasKey(node, \"styles\") || !hasKey(node.styles, \"text\"))\n      ) {\n        acc.push({\n          node: node,\n          path: index.paths[node.id]\n        });\n      }\n    }\n    return acc;\n  },\n  []);\n}\n","import {\n  findTextNodesWithInlineStyles,\n  InlineTextStyleNodes\n} from \"../analysis/findStyles\";\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as any;\n\nctx.addEventListener(\"message\", ({ data: { fileData, index } }) => {\n  const result: InlineTextStyleNodes = findTextNodesWithInlineStyles(\n    fileData,\n    index\n  );\n  ctx.postMessage(result);\n});\n\nexport default {};\n"],"sourceRoot":""}